import time
import numpy as np
from numpy import pi
import pylab as pl
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
import matplotlib.transforms as transforms
from mpl_toolkits import mplot3d


def MotionGeneration_zero(xold, ut):
    # xold contains x1 and x2 at previous time
    # ut contains u1 and u2
    # output contains x1 and x2 after applying ut
    siga = 0.03
    if np.linalg.norm(ut) < 0.001:
        motnoise = np.array([0, 0])
    else:
        motnoise = np.random.normal(0, siga, 2)
    x = xold + ut + motnoise
    return x


def Kalman_filter_one(muold, Sigmaold, ut, yt):
    # muold should contain position estimate at previous time (vector of length 2)
    # Sigmaold should contain covariance matrix at previous time
    # ut contains the input command at time t (vector of length 2)
    # yt contains the measurement data (4 x 2 array: distance, direction for each of the four beacons)
    #     see just below the order of the beacons:
    br = np.array([[4.5, 3], [-4.5, 3], [4.5, -3], [-4.5, -3]])
    # stds  (you can change these to play around -- then do so also in virtual data generator)
    siga = 0.03
    sigrel = 0.03
    sigb = 0.03
    # HERE THE SOLUTION
    Rt = np.array([[siga**2, 0], [0, siga**2]])
    # predict
    mubar = muold + ut
    if np.linalg.norm(ut) < 0.001:
        Sigmabar = Sigmaold
    else:
        Sigmabar = Sigmaold + Rt

    # update
    for s in range(4):
        zhat = br[s] - mubar

        y = np.array([yt[s, 0] - np.linalg.norm(br[s] - mubar),
                      (yt[s, 1] - np.arctan2((br[s] - mubar)[0], (br[s] - mubar)[1]) + pi) % (2 * pi) - pi])

        x0, x1 = mubar
        nrm_2 = ((br[s][0] - x0) ** 2 + (br[s][1] - x1) ** 2 + 1e-6)
        H_j = np.array([[(x0 - br[s][0]) / np.sqrt(nrm_2), (x1 - br[s][1]) / np.sqrt(nrm_2)],
                        [-(x0-br[s][0]) / nrm_2, (x0 - br[s][0]) / nrm_2]])
        Qt = np.array([[(sigrel*np.sqrt(nrm_2))**2, 0],
                       [0, (sigb**2)]])

        S = H_j @ Sigmabar @ H_j.T + Qt
        K = Sigmabar @ H_j.T @ np.linalg.inv(S)

        mubar = mubar + K @ y
        Sigmabar = (np.eye(2) - K @ H_j) @ Sigmabar

    return mubar, Sigmabar


def MeasurementOutput_one(x):
    # x is the current robot position
    # output y is the array described in Kalman_filter_one
    sigrel = 0.05
    sigb = 0.12

    beaconrefs = np.array([[4.5, 3], [-4.5, 3], [4.5, -3], [-4.5, -3]])
    y = np.zeros((4, 2))
    y1 = np.zeros((4, 2))
    for s in range(4):
        zmu = beaconrefs[s] - x
        dist = np.linalg.norm(zmu)
        direc = np.arctan2(zmu[0], zmu[1])
        y[s] = np.array([dist, direc]) + np.array(
            [np.random.normal(0, sigrel) * dist, np.random.normal(0, sigb) * direc])
        y1[s] = np.array([np.cos(y[s][1]) * y[s][0], np.sin(y[s][1]) * y[s][0]])
    return y


# initial true position, estimated position, and uncertainty on initial estimation (this last one be big)
x = np.array([0, 0])
mu = np.array([0, 0])
Sig = 100 * np.identity(2)

# sequence of input commands (change this as you want)
u_seq = np.array([[0, 0.5], [0, 0.5], [0.3, -0.3], [0.3, 0], [0, -0.5], [0, 0], [0, 0]])

# buffers for the graphs
xonetrue = []
xtwotrue = []
xoneestimate = []
xtwoestimate = []
Ellh = []
Ellv = []
Ellangle = []
xonetrue.append(x[0])
xtwotrue.append(x[1])
xoneestimate.append(mu[0])
xtwoestimate.append(mu[1])
w, v = np.linalg.eigh(Sig)
Ellh.append(6 * w[0]);
Ellv.append(6 * w[1]);
Ellangle.append(np.arctan2(v[1, 0], v[0, 0]))

# Running the simulation
for t in range(len(u_seq)):
    muold = mu
    Sigold = Sig
    xold = x
    unow = u_seq[t]
    # 1. Real Robot simulation
    x = MotionGeneration_zero(xold, unow)
    xonetrue.append(x[0])
    xtwotrue.append(x[1])
    # !!!! change next line when using the more realistic sensor model in Ex.2
    # ynow = MeasurementOutput_zero(x)
    ynow = MeasurementOutput_one(x)
    # 2. Kalman Filter estimate
    # !!!! change next line when using the EKF of Ex.2
    # mu, Sig = Kalman_filter_zero(muold, Sigold, unow, ynow)
    mu, Sig = Kalman_filter_one(muold, Sigold, unow, ynow)
    xoneestimate.append(mu[0])
    xtwoestimate.append(mu[1])

    w, v = np.linalg.eigh(Sig)
    Ellh.append(6 * w[0]);
    Ellv.append(6 * w[1]);
    Ellangle.append(np.arctan2(v[1, 0], v[0, 0]))

# The following code plots the result of the simulation.
# True robot trajectory is represented as connected blue circles,
# Kalman filter estimate as red crosses with uncertainty ellipse (except at time zero -- too big),
# beacons are green crosses.

fig, axnstd = plt.subplots(figsize=(10, 6))
pl.plot([-4.5, 4.5, -4.5, 4.5], [-3, -3, 3, 3], 'g+')
pl.plot(xonetrue, xtwotrue, 'bo')
pl.plot(xonetrue, xtwotrue, 'b-')
pl.plot(xoneestimate, xtwoestimate, 'rx')
axnstd.set_aspect("equal")

for t in range(len(u_seq)):
    e1 = Ellipse([xoneestimate[t + 1], xtwoestimate[t + 1]], Ellh[t + 1], Ellv[t + 1], Ellangle[t + 1], linewidth=2,
                 fill=False)
    axnstd.add_patch(e1)

pl.show()
